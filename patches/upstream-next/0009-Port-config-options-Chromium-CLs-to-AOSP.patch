From c6a3fd8f9749be152217652757654a3ba07968c9 Mon Sep 17 00:00:00 2001
From: Dan Stahr <danstahr@google.com>
Date: Tue, 10 Jan 2023 10:05:15 +0000
Subject: [PATCH] Port config options Chromium CLs to AOSP.

See https://crrev.com/c/4111217 and https://crrev.com/c/4145865
for details.

Test: m

Change-Id: I71f557368977d6e506fa397d9e55323ccd020d1f
---
 components/cronet/android/BUILD.gn            |   3 +
 .../net/ConnectionMigrationOptions.java       | 400 +++++++++++
 .../src/org/chromium/net/CronetEngine.java    |  69 ++
 .../api/src/org/chromium/net/DnsOptions.java  | 433 ++++++++++++
 .../net/ExperimentalCronetEngine.java         | 309 +++++++-
 .../chromium/net/ICronetEngineBuilder.java    |  51 +-
 .../api/src/org/chromium/net/QuicOptions.java | 665 ++++++++++++++++++
 .../net/impl/CronetUrlRequestContext.java     |   2 +-
 8 files changed, 1928 insertions(+), 4 deletions(-)
 create mode 100644 components/cronet/android/api/src/org/chromium/net/ConnectionMigrationOptions.java
 create mode 100644 components/cronet/android/api/src/org/chromium/net/DnsOptions.java
 create mode 100644 components/cronet/android/api/src/org/chromium/net/QuicOptions.java

diff --git a/components/cronet/android/BUILD.gn b/components/cronet/android/BUILD.gn
index d6159e409eca8..c9b2031f51cdf 100644
--- a/components/cronet/android/BUILD.gn
+++ b/components/cronet/android/BUILD.gn
@@ -230,8 +230,10 @@ android_library("cronet_api_java") {
   sources = [
     "api/src/org/chromium/net/BidirectionalStream.java",
     "api/src/org/chromium/net/CallbackException.java",
+    "api/src/org/chromium/net/ConnectionMigrationOptions.java",
     "api/src/org/chromium/net/CronetEngine.java",
     "api/src/org/chromium/net/CronetException.java",
+    "api/src/org/chromium/net/DnsOptions.java",
     "api/src/org/chromium/net/CronetProvider.java",
     "api/src/org/chromium/net/ExperimentalBidirectionalStream.java",
     "api/src/org/chromium/net/ExperimentalCronetEngine.java",
@@ -242,6 +244,7 @@ android_library("cronet_api_java") {
     "api/src/org/chromium/net/NetworkQualityRttListener.java",
     "api/src/org/chromium/net/NetworkQualityThroughputListener.java",
     "api/src/org/chromium/net/QuicException.java",
+    "api/src/org/chromium/net/QuicOptions.java",
     "api/src/org/chromium/net/RequestFinishedInfo.java",
     "api/src/org/chromium/net/UploadDataProvider.java",
     "api/src/org/chromium/net/UploadDataProviders.java",
diff --git a/components/cronet/android/api/src/org/chromium/net/ConnectionMigrationOptions.java b/components/cronet/android/api/src/org/chromium/net/ConnectionMigrationOptions.java
new file mode 100644
index 0000000000000..b52d38d7fa109
--- /dev/null
+++ b/components/cronet/android/api/src/org/chromium/net/ConnectionMigrationOptions.java
@@ -0,0 +1,400 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.net;
+
+import androidx.annotation.Nullable;
+
+/**
+ * A class configuring Cronet's connection migration functionality.
+ *
+ * <p>Connection migration stops open connections to servers from being destroyed when the
+ * client device switches its L4 connectivity (typically the IP address as a result of using
+ * a different network). This is particularly common with mobile devices losing
+ * wifi connectivity and switching to cellular data, or vice versa (a.k.a. the parking lot
+ * problem). QUIC uses connection identifiers which are independent of the underlying
+ * transport layer to make this possible. If the client connects to a new network and wants
+ * to preserve the existing connection, they can do so by using a connection identifier the server
+ * knows to be a continuation of the existing connection.
+ *
+ * <p>The features are only available for QUIC connections and the server needs to support
+ * connection migration.
+ *
+ * @see <a href="https://www.rfc-editor.org/rfc/rfc9000.html#section-9">Connection
+ *     Migration specification</a>
+ */
+public class ConnectionMigrationOptions {
+    @Nullable
+    private final Boolean mEnableDefaultNetworkMigration;
+    @Nullable
+    private final Boolean mEnablePathDegradationMigration;
+    @Nullable
+    private final Boolean mAllowServerMigration;
+    @Nullable
+    private final Boolean mMigrateIdleConnections;
+    @Nullable
+    private final Long mIdleMigrationPeriodSeconds;
+    @Nullable
+    private final Boolean mRetryPreHandshakeErrorsOnNonDefaultNetwork;
+    @Nullable
+    private final Boolean mAllowNonDefaultNetworkUsage;
+    @Nullable
+    private final Long mMaxTimeOnNonDefaultNetworkSeconds;
+    @Nullable
+    private final Integer mMaxWriteErrorNonDefaultNetworkMigrationsCount;
+    @Nullable
+    private final Integer mMaxPathDegradingNonDefaultMigrationsCount;
+
+    /**
+     * See {@link Builder#enableDefaultNetworkMigration}
+     */
+    @Nullable
+    public Boolean getEnableDefaultNetworkMigration() {
+        return mEnableDefaultNetworkMigration;
+    }
+
+    /**
+     * See {@link Builder#enablePathDegradationMigration}
+     */
+    @Nullable
+    public Boolean getEnablePathDegradationMigration() {
+        return mEnablePathDegradationMigration;
+    }
+
+    /**
+     * See {@link Builder#allowServerMigration}
+     *
+     * {@hide}
+     */
+    @Nullable
+    @Experimental
+    public Boolean getAllowServerMigration() {
+        return mAllowServerMigration;
+    }
+
+    /**
+     * See {@link Builder#migrateIdleConnections}
+     *
+     * {@hide}
+     */
+    @Nullable
+    @Experimental
+    public Boolean getMigrateIdleConnections() {
+        return mMigrateIdleConnections;
+    }
+
+    /**
+     * See {@link Builder#setIdleMigrationPeriodSeconds}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Long getIdleMigrationPeriodSeconds() {
+        return mIdleMigrationPeriodSeconds;
+    }
+
+    /**
+     * See {@link Builder#retryPreHandshakeErrorsOnNonDefaultNetwork}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getRetryPreHandshakeErrorsOnNonDefaultNetwork() {
+        return mRetryPreHandshakeErrorsOnNonDefaultNetwork;
+    }
+
+    /**
+     * See {@link Builder#allowNonDefaultNetworkUsage}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getAllowNonDefaultNetworkUsage() {
+        return mAllowNonDefaultNetworkUsage;
+    }
+
+    /**
+     * See {@link Builder#setMaxTimeOnNonDefaultNetworkSeconds}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Long getMaxTimeOnNonDefaultNetworkSeconds() {
+        return mMaxTimeOnNonDefaultNetworkSeconds;
+    }
+
+    /**
+     * See {@link Builder#setMaxWriteErrorNonDefaultNetworkMigrationsCount}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Integer getMaxWriteErrorNonDefaultNetworkMigrationsCount() {
+        return mMaxWriteErrorNonDefaultNetworkMigrationsCount;
+    }
+
+    /**
+     * See {@link Builder#setMaxPathDegradingNonDefaultNetworkMigrationsCount}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Integer getMaxPathDegradingNonDefaultMigrationsCount() {
+        return mMaxPathDegradingNonDefaultMigrationsCount;
+    }
+
+    ConnectionMigrationOptions(Builder builder) {
+        this.mEnableDefaultNetworkMigration = builder.mEnableDefaultNetworkMigration;
+        this.mEnablePathDegradationMigration = builder.mEnablePathDegradationMigration;
+        this.mAllowServerMigration = builder.mAllowServerMigration;
+        this.mMigrateIdleConnections = builder.mMigrateIdleConnections;
+        this.mIdleMigrationPeriodSeconds = builder.mIdleConnectionMigrationPeriodSeconds;
+        this.mRetryPreHandshakeErrorsOnNonDefaultNetwork =
+                builder.mRetryPreHandshakeErrorsOnAlternateNetwork;
+        this.mAllowNonDefaultNetworkUsage = builder.mAllowNonDefaultNetworkUsage;
+        this.mMaxTimeOnNonDefaultNetworkSeconds = builder.mMaxTimeOnNonDefaultNetworkSeconds;
+        this.mMaxWriteErrorNonDefaultNetworkMigrationsCount = builder.mMaxWriteErrorNonDefaultNetworkMigrationsCount;
+        this.mMaxPathDegradingNonDefaultMigrationsCount = builder.mMaxPathDegradingNonDefaultMigrationsCount;
+    }
+
+    /**
+     * Builder for {@link ConnectionMigrationOptions}.
+     */
+    public static class Builder {
+        @Nullable
+        private Boolean mEnableDefaultNetworkMigration;
+        @Nullable
+        private Boolean mEnablePathDegradationMigration;
+        @Nullable
+        private Boolean mAllowServerMigration;
+        @Nullable
+        private Boolean mMigrateIdleConnections;
+        @Nullable
+        private Long mIdleConnectionMigrationPeriodSeconds;
+        @Nullable
+        private Boolean mRetryPreHandshakeErrorsOnAlternateNetwork;
+        @Nullable
+        private Boolean mAllowNonDefaultNetworkUsage;
+        @Nullable
+        private Long mMaxTimeOnNonDefaultNetworkSeconds;
+        @Nullable
+        private Integer mMaxWriteErrorNonDefaultNetworkMigrationsCount;
+        @Nullable
+        private Integer mMaxPathDegradingNonDefaultMigrationsCount;
+
+        Builder() {}
+
+        /**
+         * Enables the possibility of migrating connections on default network change. If enabled,
+         * active QUIC connections will be migrated onto the new network when the platform indicates
+         * that the default network is changing.
+         *
+         * @see <a href="https://developer.android.com/training/basics/network-ops/reading-network-state#listening-events">Android
+         *     Network State</a>
+         *
+         * @return this builder for chaining
+         */
+        public Builder enableDefaultNetworkMigration(
+                boolean enableDefaultNetworkConnectionMigration) {
+            this.mEnableDefaultNetworkMigration = enableDefaultNetworkConnectionMigration;
+            return this;
+        }
+
+        /**
+         * Enables the possibility of migrating connections if the current path is performing
+         * poorly.
+         *
+         * <p>Depending on other configuration, this can result to migrating the connections within
+         * the same default network, or to a non-default network.
+         *
+         * @see #allowNonDefaultNetworkUsage(boolean)
+         *
+         * @return this builder for chaining
+         */
+        public Builder enablePathDegradationMigration(boolean enable) {
+            this.mEnablePathDegradationMigration = enable;
+            return this;
+        }
+
+        /**
+         * Enables the possibility of migrating connections to an alternate server address
+         * at the server's request.
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder allowServerMigration(boolean allowServerMigration) {
+            this.mAllowServerMigration = allowServerMigration;
+            return this;
+        }
+
+        /**
+         * Configures whether migration of idle connections should be enabled or not.
+         *
+         * <p>If set to true, idle connections will be migrated too, as long as they haven't been
+         * idle for too long. The setting is shared for all connection migration types. The maximum
+         * idle period for which connections will still be migrated can be customized using {@link
+         * #setIdleMigrationPeriodSeconds}.
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder migrateIdleConnections(boolean migrateIdleConnections) {
+            this.mMigrateIdleConnections = migrateIdleConnections;
+            return this;
+        }
+
+        /**
+         * Sets the maximum idle period for which connections will still be migrated, in seconds.
+         * The setting is shared for all connection migration types.
+         *
+         * <p>Only relevant if {@link #migrateIdleConnections(boolean)} is enabled.
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setIdleMigrationPeriodSeconds(
+                long idleConnectionMigrationPeriodSeconds) {
+            this.mIdleConnectionMigrationPeriodSeconds = idleConnectionMigrationPeriodSeconds;
+            return this;
+        }
+
+        /**
+         * Sets whether connections can be migrated to an alternate network when Cronet detects
+         * a degradation of the path currently in use.
+         *
+         * <p>Note: This setting can result in requests being sent on non-default metered networks.
+         * Make sure you're using metered networks sparingly, and fine tune parameters like
+         * {@link #setMaxPathDegradingNonDefaultNetworkMigrationsCount(int)}
+         * and {@link #setMaxTimeOnNonDefaultNetworkSeconds} to limit the time on non-default
+         * networks.
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder allowNonDefaultNetworkUsage(boolean enable) {
+            this.mAllowNonDefaultNetworkUsage = enable;
+            return this;
+        }
+
+        /**
+         * Sets the maximum period for which connections migrated to non-default networks remain
+         * there before they're migrated back. This time is not cumulative - each migration off
+         * the default network for each connection measures and compares to this value separately.
+         *
+         * <p>Only relevant if {@link #allowNonDefaultNetworkUsage(boolean)} is enabled.
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setMaxTimeOnNonDefaultNetworkSeconds(
+                long maxTimeOnNonDefaultNetworkSeconds) {
+            this.mMaxTimeOnNonDefaultNetworkSeconds = maxTimeOnNonDefaultNetworkSeconds;
+            return this;
+        }
+
+        /**
+         * Sets the maximum number of migrations to the non-default network upon encountering write
+         * errors. Counted cumulatively per network per connection.
+         *
+         * <p>Only relevant if {@link #allowNonDefaultNetworkUsage(boolean)} is enabled.
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setMaxWriteErrorNonDefaultNetworkMigrationsCount(
+                int maxWriteErrorNonDefaultMigrationsCount) {
+            this.mMaxWriteErrorNonDefaultNetworkMigrationsCount = maxWriteErrorNonDefaultMigrationsCount;
+            return this;
+        }
+
+        /**
+         * Sets the maximum number of migrations to the non-default network upon encountering path
+         * degradation for the existing connection. Counted cumulatively per network per connection.
+         *
+         * <p>Only relevant if {@link #allowNonDefaultNetworkUsage(boolean)} is enabled.
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setMaxPathDegradingNonDefaultNetworkMigrationsCount(
+                int maxPathDegradingNonDefaultMigrationsCount) {
+            this.mMaxPathDegradingNonDefaultMigrationsCount = maxPathDegradingNonDefaultMigrationsCount;
+            return this;
+        }
+
+        /**
+         * Sets whether connections with pre-handshake errors should be retried on an alternative
+         * network.
+         *
+         * <p>If true, a new connection may be established an alternate network if it fails
+         * on the default network before handshake is confirmed.
+         *
+         * <p>Note: similarly to {@link #allowNonDefaultNetworkUsage(boolean)} this setting can
+         * result in requests being sent on non-default metered networks. Use with caution!
+         *
+         * @return this builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder retryPreHandshakeErrorsOnNonDefaultNetwork(
+                boolean retryPreHandshakeErrorsOnAlternateNetwork) {
+            this.mRetryPreHandshakeErrorsOnAlternateNetwork =
+                    retryPreHandshakeErrorsOnAlternateNetwork;
+            return this;
+        }
+
+        /**
+         * Creates and returns the final {@link ConnectionMigrationOptions} instance, based on the
+         * values in this builder.
+         */
+        public ConnectionMigrationOptions build() {
+            return new ConnectionMigrationOptions(this);
+        }
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /**
+     * An annotation for APIs which are not considered stable yet.
+     *
+     * <p>Applications using experimental APIs must acknowledge that they're aware of using APIs
+     * that are not considered stable. The APIs might change functionality, break or cease to exist
+     * without notice.
+     *
+     * <p>It's highly recommended to reach out to Cronet maintainers ({@code net-dev@chromium.org})
+     * before using one of the APIs annotated as experimental outside of debugging
+     * and proof-of-concept code. Be ready to help to help polishing the API, or for a "sorry,
+     * really not production ready yet".
+     *
+     * <p>If you still want to use an experimental API in production, you're doing so at your
+     * own risk. You have been warned.
+     *
+     * {@hide}
+     */
+    public @interface Experimental {}
+}
diff --git a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
index 9941d67bbd97a..5808f3f465695 100644
--- a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
@@ -306,6 +306,75 @@ public abstract class CronetEngine {
             return this;
         }
 
+        /**
+         * Configures the behavior of Cronet when using QUIC. For more details, see documentation
+         * of {@link QuicOptions} and the individual methods of {@link QuicOptions.Builder}.
+         *
+         * <p>Only relevant if {@link #enableQuic(boolean)} is enabled.
+         *
+         * @return the builder to facilitate chaining.
+         */
+        @QuicOptions.Experimental
+        public Builder setQuicOptions(QuicOptions quicOptions) {
+            mBuilderDelegate.setQuicOptions(quicOptions);
+            return this;
+        }
+
+        /**
+         * @see #setQuicOptions(QuicOptions)
+         */
+        @QuicOptions.Experimental
+        public Builder setQuicOptions(QuicOptions.Builder quicOptionsBuilder) {
+            return setQuicOptions(quicOptionsBuilder.build());
+        }
+
+        /**
+         * Configures the behavior of hostname lookup. For more details, see documentation
+         * of {@link DnsOptions} and the individual methods of {@link DnsOptions.Builder}.
+         *
+         * <p>Only relevant if {@link #enableQuic(boolean)} is enabled.
+         *
+         * @return the builder to facilitate chaining.
+         */
+        @DnsOptions.Experimental
+        public Builder setDnsOptions(DnsOptions dnsOptions) {
+            mBuilderDelegate.setDnsOptions(dnsOptions);
+            return this;
+        }
+
+        /**
+         * @see #setDnsOptions(DnsOptions)
+         */
+        @DnsOptions.Experimental
+        public Builder setDnsOptions(DnsOptions.Builder dnsOptions) {
+            return setDnsOptions(dnsOptions.build());
+        }
+
+        /**
+         * Configures the behavior of connection migration. For more details, see documentation
+         * of {@link ConnectionMigrationOptions} and the individual methods of {@link
+         * ConnectionMigrationOptions.Builder}.
+         *
+         * <p>Only relevant if {@link #enableQuic(boolean)} is enabled.
+         *
+         * @return the builder to facilitate chaining.
+         */
+        @ConnectionMigrationOptions.Experimental
+        public Builder setConnectionMigrationOptions(
+                ConnectionMigrationOptions connectionMigrationOptions) {
+            mBuilderDelegate.setConnectionMigrationOptions(connectionMigrationOptions);
+            return this;
+        }
+
+        /**
+         * @see #setConnectionMigrationOptions(ConnectionMigrationOptions)
+         */
+        @ConnectionMigrationOptions.Experimental
+        public Builder setConnectionMigrationOptions(
+                ConnectionMigrationOptions.Builder connectionMigrationOptionsBuilder) {
+            return setConnectionMigrationOptions(connectionMigrationOptionsBuilder.build());
+        }
+
         /**
          * Build a {@link CronetEngine} using this builder's configuration.
          * @return constructed {@link CronetEngine}.
diff --git a/components/cronet/android/api/src/org/chromium/net/DnsOptions.java b/components/cronet/android/api/src/org/chromium/net/DnsOptions.java
new file mode 100644
index 0000000000000..f81048e887c8e
--- /dev/null
+++ b/components/cronet/android/api/src/org/chromium/net/DnsOptions.java
@@ -0,0 +1,433 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.net;
+
+import android.os.Build.VERSION_CODES;
+
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+
+import java.time.Duration;
+
+/**
+ * A class configuring Cronet's host resolution functionality. Note that while we refer to {@code
+ * DNS} as the most common mechanism being used for brevity, settings apply to other means of
+ * resolving hostnames like hosts file resolution.
+ *
+ * <p>Cronet resolve hostnames in two ways - either by using the system resolver (using {@code
+ * getaddrinfo} provided by system libraries), or by using a custom resolver which is built into the
+ * networking stack Cronet uses.
+ *
+ * <p>The built-in stack provides several advantages over using the system resolver:
+ *
+ * <ul>
+ *   <li>It has been tailored to the needs of the networking stack, particularly speed and
+ *       stability.
+ *   <li>{@code getaddrinfo} is a blocking call which requires dedicating worker threads and makes
+ *       cancellation impossible (we need to abandon the thread until the call completes)
+ *   <li>The {@code getaddrinfo} interface gives no insight into the root cause of failures
+ *   <li>{@code struct addrinfo} provides no TTL (Time To Live) of the returned addresses. This
+ *       restricts flexibility of handling caching (e.g. allowing the use of stale DNS records) and
+ *       requires us to either rely on OS DNS caches, or be extremely conservative with the TTL.
+ *   <li>As part of the OS, {@code getaddrinfo} evolves slowly. Using a custom stack enables Cronet
+ *       to introduce features like encrypted DNS faster.
+ * </ul>
+ *
+ * <p>Most configuration in this class is only applicable if the built-in DNS resolver is used.
+ */
+public final class DnsOptions {
+    @Nullable
+    private final Boolean mUseBuiltInDnsResolver;
+    @Nullable
+    private final Boolean mPersistHostCache;
+    @Nullable
+    private final Boolean mEnableStaleDns;
+    @Nullable
+    private final Long mPersistHostCachePeriodMillis;
+
+    @Nullable
+    private final Boolean mPreestablishConnectionsToStaleDnsResults;
+    @Nullable
+    private final StaleDnsOptions mStaleDnsOptions;
+
+    DnsOptions(Builder builder) {
+        this.mEnableStaleDns = builder.mEnableStaleDns;
+        this.mStaleDnsOptions = builder.mStaleDnsOptions;
+        this.mPersistHostCachePeriodMillis = builder.mPersistHostCachePeriodMillis;
+        this.mPreestablishConnectionsToStaleDnsResults =
+                builder.mPreestablishConnectionsToStaleDnsResults;
+        this.mUseBuiltInDnsResolver = builder.mUseBuiltInDnsResolver;
+        this.mPersistHostCache = builder.mPersistHostCache;
+    }
+
+    /**
+     * See {@link Builder#useBuiltInDnsResolver}
+     */
+    @Nullable
+    public Boolean getUseBuiltInDnsResolver() {
+        return mUseBuiltInDnsResolver;
+    }
+
+    /**
+     * See {@link Builder#persistHostCache}
+     */
+    @Nullable
+    public Boolean getPersistHostCache() {
+        return mPersistHostCache;
+    }
+
+    /**
+     * See {@link Builder#enableStaleDns}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getEnableStaleDns() {
+        return mEnableStaleDns;
+    }
+
+    /**
+     * See {@link Builder#setPersistHostCachePeriodMillis}
+     */
+    @Nullable
+    public Long getPersistHostCachePeriodMillis() {
+        return mPersistHostCachePeriodMillis;
+    }
+
+    /**
+     * See {@link Builder#preestablishConnectionsToStaleDnsResults}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getPreestablishConnectionsToStaleDnsResults() {
+        return mPreestablishConnectionsToStaleDnsResults;
+    }
+
+    /**
+     * See {@link Builder#setStaleDnsOptions}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public StaleDnsOptions getStaleDnsOptions() {
+        return mStaleDnsOptions;
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /**
+     * A class configuring Cronet's stale DNS functionality.
+     *
+     * <p>DNS resolution is one of the steps on the critical path to making a URL request, but it
+     * can be slow for various reasons (underlying network latency, buffer bloat, packet loss,
+     * etc.).
+     *
+     * <p>Depending on the use case, it might be worthwhile for an app developer to trade off
+     * guaranteed DNS record freshness for better availability of DNS records.
+     *
+     * <p>Stale results can include both:
+     *
+     * <ul>
+     *   <li>results returned from the current network's DNS server, but past their time-to-live,
+     * and <li>results returned from a previous network's DNS server, whether expired or not.
+     * </ul>
+     *
+     * <p>For detailed explanation of the configuration options see javadoc on
+     * {@link StaleDnsOptions.Builder} methods.
+     *
+     * {@hide}
+     */
+    @Experimental
+    public static class StaleDnsOptions {
+        @Nullable
+        public Long getFreshLookupTimeoutMillis() {
+            return mFreshLookupTimeoutMillis;
+        }
+
+        @Nullable
+        public Long getMaxExpiredDelayMillis() {
+            return mMaxExpiredDelayMillis;
+        }
+
+        @Nullable
+        public Boolean getAllowCrossNetworkUsage() {
+            return mAllowCrossNetworkUsage;
+        }
+
+        @Nullable
+        public Boolean getUseStaleOnNameNotResolved() {
+            return mUseStaleOnNameNotResolved;
+        }
+
+        public static Builder builder() {
+            return new Builder();
+        }
+
+        @Nullable
+        private final Long mFreshLookupTimeoutMillis;
+        @Nullable
+        private final Long mMaxExpiredDelayMillis;
+        @Nullable
+        private final Boolean mAllowCrossNetworkUsage;
+        @Nullable
+        private final Boolean mUseStaleOnNameNotResolved;
+
+        StaleDnsOptions(Builder builder) {
+            this.mFreshLookupTimeoutMillis = builder.mFreshLookupTimeoutMillis;
+            this.mMaxExpiredDelayMillis = builder.mMaxExpiredDelayMillis;
+            this.mAllowCrossNetworkUsage = builder.mAllowCrossNetworkUsage;
+            this.mUseStaleOnNameNotResolved = builder.mUseStaleOnNameNotResolved;
+        }
+
+        /**
+         * Builder for {@link StaleDnsOptions}.
+         *
+         * {@hide}
+         */
+        public static final class Builder {
+            private Long mFreshLookupTimeoutMillis;
+            private Long mMaxExpiredDelayMillis;
+            private Boolean mAllowCrossNetworkUsage;
+            private Boolean mUseStaleOnNameNotResolved;
+
+            Builder() {}
+
+            /**
+             * Sets how long (in milliseconds) to wait for a DNS request to return before using a
+             * stale result instead. If set to zero, returns stale results instantly but continues
+             * the DNS request in the background to update the cache.
+             *
+             * @return the builder for chaining
+             */
+            public Builder setFreshLookupTimeoutMillis(long freshLookupTimeoutMillis) {
+                this.mFreshLookupTimeoutMillis = freshLookupTimeoutMillis;
+                return this;
+            }
+
+            /**
+             * Same as {@link #setFreshLookupTimeoutMillis(long)} but using {@link
+             * java.time.Duration}.
+             *
+             * @return the builder for chaining
+             */
+            @RequiresApi(VERSION_CODES.O)
+            public Builder setFreshLookupTimeout(Duration freshLookupTimeout) {
+                return setFreshLookupTimeoutMillis(freshLookupTimeout.toMillis());
+            }
+
+            /**
+             * Sets how long (in milliseconds) past expiration to consider using expired results.
+             * Setting the value to zero means expired records can be used indefinitely.
+             *
+             * @return the builder for chaining
+             */
+            public Builder setMaxExpiredDelayMillis(long maxExpiredDelayMillis) {
+                this.mMaxExpiredDelayMillis = maxExpiredDelayMillis;
+                return this;
+            }
+
+            /**
+             * Same as {@link #setMaxExpiredDelayMillis(long)} but using {@link java.time.Duration}.
+             *
+             * @return the builder for chaining
+             */
+            @RequiresApi(VERSION_CODES.O)
+            public Builder setMaxExpiredDelayMillis(Duration maxExpiredDelay) {
+                return setMaxExpiredDelayMillis(maxExpiredDelay.toMillis());
+            }
+
+            /**
+             * Sets whether to return results originating from other networks or not. Normally,
+             * Cronet clears the DNS cache entirely when switching connections, e.g. between two
+             * Wi-Fi networks or from Wi-Fi to 4G.
+             *
+             * @return the builder for chaining
+             */
+            public Builder allowCrossNetworkUsage(boolean allowCrossNetworkUsage) {
+                this.mAllowCrossNetworkUsage = allowCrossNetworkUsage;
+                return this;
+            }
+
+            /**
+             * Sets whether to allow use of stale DNS results when network resolver fails to resolve
+             * the hostname.
+             *
+             * <p>Depending on the use case, if Cronet quickly sees a fresh failure, it may be
+             * desirable to use the failure as it is technically the fresher result, and we had such
+             * a fresh result quickly; or, prefer having any result (even if stale) to use over
+             * having a failure.
+             *
+             * @return the builder for chaining
+             */
+            public Builder useStaleOnNameNotResolved(boolean useStaleOnNameNotResolved) {
+                this.mUseStaleOnNameNotResolved = useStaleOnNameNotResolved;
+                return this;
+            }
+
+            /**
+             * Creates and returns the final {@link StaleDnsOptions} instance, based on the values
+             * in this builder.
+             */
+            public StaleDnsOptions build() {
+                return new StaleDnsOptions(this);
+            }
+        }
+    }
+
+    /**
+     * Builder for {@link DnsOptions}.
+     */
+    public static final class Builder {
+        @Nullable
+        private Boolean mUseBuiltInDnsResolver;
+        @Nullable
+        private Boolean mEnableStaleDns;
+        @Nullable
+        private StaleDnsOptions mStaleDnsOptions;
+        @Nullable
+        private Boolean mPersistHostCache;
+        @Nullable
+        private Long mPersistHostCachePeriodMillis;
+        @Nullable
+        private Boolean mPreestablishConnectionsToStaleDnsResults;
+
+        Builder() {}
+
+        public Builder useBuiltInDnsResolver(boolean enable) {
+            this.mUseBuiltInDnsResolver = enable;
+            return this;
+        }
+
+        /**
+         * Sets whether to use stale DNS results at all.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder enableStaleDns(boolean enable) {
+            this.mEnableStaleDns = enable;
+            return this;
+        }
+
+        /**
+         * Sets detailed configuration for stale DNS.
+         *
+         * Only relevant if {@link #enableStaleDns(boolean)} is set.
+         *
+         * @return this builder for chaining.
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setStaleDnsOptions(StaleDnsOptions staleDnsOptions) {
+            this.mStaleDnsOptions = staleDnsOptions;
+            return this;
+        }
+
+        /**
+         * @see #setStaleDnsOptions(StaleDnsOptions)
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setStaleDnsOptions(StaleDnsOptions.Builder staleDnsOptionsBuilder) {
+            return setStaleDnsOptions(staleDnsOptionsBuilder.build());
+        }
+
+        /**
+         * Sets whether Cronet should use stale cached DNS records to pre-establish connections.
+         *
+         * <p>If enabled, Cronet will optimistically pre-establish connections to servers that
+         * matched the hostname at some point in the past and were cached but the cache entry
+         * expired. Such connections won't be used further until a new DNS lookup confirms the
+         * cached record was up to date.
+         *
+         * <p>To use cached DNS records straight away, use {@link #enableStaleDns} and {@link
+         * StaleDnsOptions} configuration options.
+         *
+         * <p>This option may not be available for all networking protocols.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder preestablishConnectionsToStaleDnsResults(boolean enable) {
+            this.mPreestablishConnectionsToStaleDnsResults = enable;
+            return this;
+        }
+
+        /**
+         * Sets whether the DNS cache should be persisted to disk.
+         *
+         * <p>Only relevant if {@link CronetEngine.Builder#setStoragePath(String)} is
+         * set.
+         *
+         * @return the builder for chaining
+         */
+        public Builder persistHostCache(boolean persistHostCache) {
+            this.mPersistHostCache = persistHostCache;
+            return this;
+        }
+
+        /**
+         * Sets the minimum period between subsequent writes to disk for DNS cache persistence.
+         *
+         * <p>Only relevant if {@link #persistHostCache(boolean)} is set to true.
+         *
+         * @return the builder for chaining
+         */
+        public Builder setPersistHostCachePeriodMillis(long persistHostCachePeriodMillis) {
+            this.mPersistHostCachePeriodMillis = persistHostCachePeriodMillis;
+            return this;
+        }
+
+        /**
+         * Same as {@link #setPersistHostCachePeriodMillis(long)} but using {@link
+         * java.time.Duration}.
+         *
+         * @return the builder for chaining
+         */
+        @RequiresApi(api = VERSION_CODES.O)
+        public Builder setPersistDelay(Duration persistToDiskPeriod) {
+            return setPersistHostCachePeriodMillis(persistToDiskPeriod.toMillis());
+        }
+
+        /**
+         * Creates and returns the final {@link DnsOptions} instance, based on the values in this
+         * builder.
+         */
+        public DnsOptions build() {
+            return new DnsOptions(this);
+        }
+    }
+
+    /**
+     * An annotation for APIs which are not considered stable yet.
+     *
+     * <p>Applications using experimental APIs must acknowledge that they're aware of using APIs
+     * that are not considered stable. The APIs might change functionality, break or cease to exist
+     * without notice.
+     *
+     * <p>It's highly recommended to reach out to Cronet maintainers ({@code net-dev@chromium.org})
+     * before using one of the APIs annotated as experimental outside of debugging
+     * and proof-of-concept code. Be ready to help to help polishing the API, or for a "sorry,
+     * really not production ready yet".
+     *
+     * <p>If you still want to use an experimental API in production, you're doing so at your
+     * own risk. You have been warned.
+     *
+     * {@hide}
+     */
+    public @interface Experimental {}
+}
diff --git a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
index defa971c49297..67a83b6edc81a 100644
--- a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
@@ -4,14 +4,20 @@
 package org.chromium.net;
 
 import android.content.Context;
+import org.chromium.net.DnsOptions.StaleDnsOptions;
 
 import androidx.annotation.VisibleForTesting;
 
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.io.IOException;
 import java.net.Proxy;
 import java.net.URL;
 import java.net.URLConnection;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Executor;
 
@@ -25,7 +31,10 @@ import java.util.concurrent.Executor;
  * future. Use at your own risk.
  *
  * {@hide since this class exposes experimental features that should be hidden.}
+ *
+ * @deprecated scheduled for deletion, don't use in new code.
  */
+@Deprecated
 public abstract class ExperimentalCronetEngine extends CronetEngine {
     /**
      * The value of a connection metric is unknown.
@@ -86,6 +95,10 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
      * may be deprecated in the future. Use at your own risk.
      */
     public static class Builder extends CronetEngine.Builder {
+        private JSONObject mParsedExperimentalOptions;
+        private final List<ExperimentalOptionsPatch> mExperimentalOptionsPatches =
+                new ArrayList<>();
+
         /**
          * Constructs a {@link Builder} object that facilitates creating a
          * {@link CronetEngine}. The default configuration enables HTTP/2 and
@@ -139,7 +152,11 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
          * @return the builder to facilitate chaining.
          */
         public Builder setExperimentalOptions(String options) {
-            mBuilderDelegate.setExperimentalOptions(options);
+            if (options == null || options.isEmpty()) {
+                mParsedExperimentalOptions = null;
+            } else {
+                mParsedExperimentalOptions = parseExperimentalOptions(options);
+            }
             return this;
         }
 
@@ -162,6 +179,7 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
 
         /**
          * Returns delegate, only for testing.
+         *
          * @hide
          */
         @VisibleForTesting
@@ -202,6 +220,250 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
             return this;
         }
 
+        @Override
+        @QuicOptions.Experimental
+        public Builder setQuicOptions(QuicOptions options) {
+            // If the delegate builder supports enabling connection migration directly, just use it
+            if (mBuilderDelegate.getSupportedConfigOptions().contains(
+                    ICronetEngineBuilder.QUIC_OPTIONS)) {
+                mBuilderDelegate.setQuicOptions(options);
+                return this;
+            }
+
+            // If not, we'll have to work around it by modifying the experimental options JSON.
+            mExperimentalOptionsPatches.add((experimentalOptions) -> {
+                JSONObject quicOptions = createDefaultIfAbsent(experimentalOptions, "QUIC");
+
+                // Note: using the experimental APIs always overwrites what's in the experimental
+                // JSON, even though "repeated" fields could in theory be additive.
+                if (!options.getQuicHostAllowlist().isEmpty()) {
+                    quicOptions.put(
+                            "host_whitelist", String.join(",", options.getQuicHostAllowlist()));
+                }
+                if (!options.getEnabledQuicVersions().isEmpty()) {
+                    quicOptions.put(
+                            "quic_version", String.join(",", options.getEnabledQuicVersions()));
+                }
+                if (!options.getConnectionOptions().isEmpty()) {
+                    quicOptions.put(
+                            "connection_options", String.join(",", options.getConnectionOptions()));
+                }
+                if (!options.getClientConnectionOptions().isEmpty()) {
+                    quicOptions.put("client_connection_options",
+                            String.join(",", options.getClientConnectionOptions()));
+                }
+                if (!options.getExtraQuicheFlags().isEmpty()) {
+                    quicOptions.put(
+                            "set_quic_flags", String.join(",", options.getExtraQuicheFlags()));
+                }
+
+                if (options.getInMemoryServerConfigsCacheSize() != null) {
+                    quicOptions.put("max_server_configs_stored_in_properties",
+                            options.getInMemoryServerConfigsCacheSize());
+                }
+
+                if (options.getHandshakeUserAgent() != null) {
+                    quicOptions.put("user_agent_id", options.getHandshakeUserAgent());
+                }
+
+                if (options.getRetryWithoutAltSvcOnQuicErrors() != null) {
+                    quicOptions.put("retry_without_alt_svc_on_quic_errors",
+                            options.getRetryWithoutAltSvcOnQuicErrors());
+                }
+
+                if (options.getEnableTlsZeroRtt() != null) {
+                    quicOptions.put("disable_tls_zero_rtt", !options.getEnableTlsZeroRtt());
+                }
+
+                if (options.getPreCryptoHandshakeIdleTimeoutSeconds() != null) {
+                    quicOptions.put("max_idle_time_before_crypto_handshake_seconds",
+                            options.getPreCryptoHandshakeIdleTimeoutSeconds());
+                }
+
+                if (options.getCryptoHandshakeTimeoutSeconds() != null) {
+                    quicOptions.put("max_time_before_crypto_handshake_seconds",
+                            options.getCryptoHandshakeTimeoutSeconds());
+                }
+
+                if (options.getIdleConnectionTimeoutSeconds() != null) {
+                    quicOptions.put("idle_connection_timeout_seconds",
+                            options.getIdleConnectionTimeoutSeconds());
+                }
+
+                if (options.getRetransmittableOnWireTimeoutMillis() != null) {
+                    quicOptions.put("retransmittable_on_wire_timeout_milliseconds",
+                            options.getRetransmittableOnWireTimeoutMillis());
+                }
+
+                if (options.getCloseSessionsOnIpChange() != null) {
+                    quicOptions.put(
+                            "close_sessions_on_ip_change", options.getCloseSessionsOnIpChange());
+                }
+
+                if (options.getGoawaySessionsOnIpChange() != null) {
+                    quicOptions.put(
+                            "goaway_sessions_on_ip_change", options.getGoawaySessionsOnIpChange());
+                }
+
+                if (options.getInitialBrokenServicePeriodSeconds() != null) {
+                    quicOptions.put("initial_delay_for_broken_alternative_service_seconds",
+                            options.getInitialBrokenServicePeriodSeconds());
+                }
+
+                if (options.getIncreaseBrokenServicePeriodExponentially() != null) {
+                    quicOptions.put("exponential_backoff_on_initial_delay",
+                            options.getIncreaseBrokenServicePeriodExponentially());
+                }
+
+                if (options.getDelayJobsWithAvailableSpdySession() != null) {
+                    quicOptions.put("delay_main_job_with_available_spdy_session",
+                            options.getDelayJobsWithAvailableSpdySession());
+                }
+            });
+            return this;
+        }
+
+        @Override
+        @DnsOptions.Experimental
+        public Builder setDnsOptions(DnsOptions options) {
+            // If the delegate builder supports enabling connection migration directly, just use it
+            if (mBuilderDelegate.getSupportedConfigOptions().contains(
+                    ICronetEngineBuilder.DNS_OPTIONS)) {
+                mBuilderDelegate.setDnsOptions(options);
+                return this;
+            }
+
+            // If not, we'll have to work around it by modifying the experimental options JSON.
+            mExperimentalOptionsPatches.add((experimentalOptions) -> {
+                JSONObject asyncDnsOptions = createDefaultIfAbsent(experimentalOptions, "AsyncDNS");
+
+                if (options.getUseBuiltInDnsResolver() != null) {
+                    asyncDnsOptions.put("enable", options.getUseBuiltInDnsResolver());
+                }
+
+                JSONObject staleDnsOptions = createDefaultIfAbsent(experimentalOptions, "StaleDNS");
+
+                if (options.getEnableStaleDns() != null) {
+                    staleDnsOptions.put("enable", options.getEnableStaleDns());
+                }
+
+                if (options.getPersistHostCache() != null) {
+                    staleDnsOptions.put("persist_to_disk", options.getPersistHostCache());
+                }
+
+                if (options.getPersistHostCachePeriodMillis() != null) {
+                    staleDnsOptions.put(
+                            "persist_delay_ms", options.getPersistHostCachePeriodMillis());
+                }
+
+                if (options.getStaleDnsOptions() != null) {
+                    StaleDnsOptions staleDnsOptionsJava = options.getStaleDnsOptions();
+
+                    if (staleDnsOptionsJava.getAllowCrossNetworkUsage() != null) {
+                        staleDnsOptions.put("allow_other_network",
+                                staleDnsOptionsJava.getAllowCrossNetworkUsage());
+                    }
+
+                    if (staleDnsOptionsJava.getFreshLookupTimeoutMillis() != null) {
+                        staleDnsOptions.put(
+                                "delay_ms", staleDnsOptionsJava.getFreshLookupTimeoutMillis());
+                    }
+
+                    if (staleDnsOptionsJava.getUseStaleOnNameNotResolved() != null) {
+                        staleDnsOptions.put("use_stale_on_name_not_resolved",
+                                staleDnsOptionsJava.getUseStaleOnNameNotResolved());
+                    }
+
+                    if (staleDnsOptionsJava.getMaxExpiredDelayMillis() != null) {
+                        staleDnsOptions.put("max_expired_time_ms",
+                                staleDnsOptionsJava.getMaxExpiredDelayMillis());
+                    }
+                }
+
+                JSONObject quicOptions = createDefaultIfAbsent(experimentalOptions, "QUIC");
+                if (options.getPreestablishConnectionsToStaleDnsResults() != null) {
+                    quicOptions.put("race_stale_dns_on_connection",
+                            options.getPreestablishConnectionsToStaleDnsResults());
+                }
+            });
+            return this;
+        }
+
+        @Override
+        @ConnectionMigrationOptions.Experimental
+        public Builder setConnectionMigrationOptions(ConnectionMigrationOptions options) {
+            // If the delegate builder supports enabling connection migration directly, just use it
+            if (mBuilderDelegate.getSupportedConfigOptions().contains(
+                    ICronetEngineBuilder.CONNECTION_MIGRATION_OPTIONS)) {
+                mBuilderDelegate.setConnectionMigrationOptions(options);
+                return this;
+            }
+
+            // If not, we'll have to work around it by modifying the experimental options JSON.
+            mExperimentalOptionsPatches.add((experimentalOptions) -> {
+                JSONObject quicOptions = createDefaultIfAbsent(experimentalOptions, "QUIC");
+
+                if (options.getEnableDefaultNetworkMigration() != null) {
+                    quicOptions.put("migrate_sessions_on_network_change_v2",
+                            options.getEnableDefaultNetworkMigration());
+                }
+                if (options.getAllowServerMigration() != null) {
+                    quicOptions.put("allow_server_migration", options.getAllowServerMigration());
+                }
+                if (options.getMigrateIdleConnections() != null) {
+                    quicOptions.put("migrate_idle_sessions", options.getMigrateIdleConnections());
+                }
+                if (options.getIdleMigrationPeriodSeconds() != null) {
+                    quicOptions.put("idle_session_migration_period_seconds",
+                            options.getIdleMigrationPeriodSeconds());
+                }
+                if (options.getRetryPreHandshakeErrorsOnNonDefaultNetwork() != null) {
+                    quicOptions.put("retry_on_alternate_network_before_handshake",
+                            options.getRetryPreHandshakeErrorsOnNonDefaultNetwork());
+                }
+                if (options.getMaxTimeOnNonDefaultNetworkSeconds() != null) {
+                    quicOptions.put("max_time_on_non_default_network_seconds",
+                            options.getMaxTimeOnNonDefaultNetworkSeconds());
+                }
+                if (options.getMaxPathDegradingNonDefaultMigrationsCount() != null) {
+                    quicOptions.put("max_migrations_to_non_default_network_on_path_degrading",
+                            options.getMaxPathDegradingNonDefaultMigrationsCount());
+                }
+                if (options.getMaxWriteErrorNonDefaultNetworkMigrationsCount() != null) {
+                    quicOptions.put("max_migrations_to_non_default_network_on_write_error",
+                            options.getMaxWriteErrorNonDefaultNetworkMigrationsCount());
+                }
+                if (options.getEnablePathDegradationMigration() != null) {
+                    boolean pathDegradationValue = options.getEnablePathDegradationMigration();
+
+                    boolean skipPortMigrationFlag = false;
+
+                    if (options.getAllowNonDefaultNetworkUsage() != null) {
+                        boolean nonDefaultNetworkValue = options.getAllowNonDefaultNetworkUsage();
+                        if (!pathDegradationValue && nonDefaultNetworkValue) {
+                            // Misconfiguration which doesn't translate easily to the JSON flags
+                            throw new IllegalArgumentException(
+                                    "Unable to turn on non-default network usage without path "
+                                            + "degradation migration!");
+                        } else if (pathDegradationValue && nonDefaultNetworkValue) {
+                            // Both values being true results in the non-default network migration
+                            // being enabled.
+                            quicOptions.put("migrate_sessions_early_v2", true);
+                            skipPortMigrationFlag = true;
+                        } else {
+                            quicOptions.put("migrate_sessions_early_v2", false);
+                        }
+                    }
+
+                    if (!skipPortMigrationFlag) {
+                        quicOptions.put("allow_port_migration", pathDegradationValue);
+                    }
+                }
+            });
+
+            return this;
+        }
+
         @Override
         public Builder enableSdch(boolean value) {
             return this;
@@ -234,8 +496,53 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
 
         @Override
         public ExperimentalCronetEngine build() {
+            if (mParsedExperimentalOptions == null && mExperimentalOptionsPatches.isEmpty()) {
+                return mBuilderDelegate.build();
+            }
+
+            if (mParsedExperimentalOptions == null) {
+                mParsedExperimentalOptions = new JSONObject();
+            }
+
+            for (ExperimentalOptionsPatch patch : mExperimentalOptionsPatches) {
+                try {
+                    patch.applyTo(mParsedExperimentalOptions);
+                } catch (JSONException e) {
+                    throw new IllegalStateException("Unable to apply JSON patch!", e);
+                }
+            }
+
+            mBuilderDelegate.setExperimentalOptions(mParsedExperimentalOptions.toString());
             return mBuilderDelegate.build();
         }
+
+        private static JSONObject parseExperimentalOptions(String jsonString) {
+            try {
+                return new JSONObject(jsonString);
+            } catch (JSONException e) {
+                throw new IllegalArgumentException("Experimental options parsing failed", e);
+            }
+        }
+
+        private static JSONObject createDefaultIfAbsent(JSONObject jsonObject, String key) {
+            JSONObject object = jsonObject.optJSONObject(key);
+            if (object == null) {
+                object = new JSONObject();
+                try {
+                    jsonObject.put(key, object);
+                } catch (JSONException e) {
+                    throw new IllegalArgumentException(
+                            "Failed adding a default object for key [" + key + "]", e);
+                }
+            }
+
+            return object;
+        }
+
+        @FunctionalInterface
+        private interface ExperimentalOptionsPatch {
+            void applyTo(JSONObject experimentalOptions) throws JSONException;
+        }
     }
 
     /**
diff --git a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
index 4cdb0bf790198..f1d2e68569eea 100644
--- a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
+++ b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 package org.chromium.net;
 
+import java.util.Collections;
 import java.util.Date;
 import java.util.Set;
 
@@ -13,31 +14,77 @@ import java.util.Set;
  * {@link org.chromium.net.CronetEngine.Builder} and
  * {@link org.chromium.net.ExperimentalCronetEngine.Builder}.
  *
- * {@hide internal class}
+ * <p>{@hide internal class}
  */
 public abstract class ICronetEngineBuilder {
+    // The fields below list values which are known to getSupportedConfigOptions().
+    //
+    // Given the fields are final the constant value associated with them is compiled into
+    // class using them. This makes it safe for all implementation to use the field in their code
+    // and not worry about version skew (new implementation aware of values the old API is not),
+    // as long as the values don't change meaning. This isn't true of enums and other dynamic
+    // structures, hence we resort to plain old good ints.
+    public static final int CONNECTION_MIGRATION_OPTIONS = 1;
+    public static final int DNS_OPTIONS = 2;
+    public static final int QUIC_OPTIONS = 3;
+
     // Public API methods.
     public abstract ICronetEngineBuilder addPublicKeyPins(String hostName, Set<byte[]> pinsSha256,
             boolean includeSubdomains, Date expirationDate);
+
     public abstract ICronetEngineBuilder addQuicHint(String host, int port, int alternatePort);
+
     public abstract ICronetEngineBuilder enableHttp2(boolean value);
+
     public abstract ICronetEngineBuilder enableHttpCache(int cacheMode, long maxSize);
+
     public abstract ICronetEngineBuilder enablePublicKeyPinningBypassForLocalTrustAnchors(
             boolean value);
+
     public abstract ICronetEngineBuilder enableQuic(boolean value);
+
     public abstract ICronetEngineBuilder enableSdch(boolean value);
+
     public ICronetEngineBuilder enableBrotli(boolean value) {
         // Do nothing for older implementations.
         return this;
     }
+
+    public ICronetEngineBuilder setQuicOptions(QuicOptions quicOptions) {
+        return this;
+    }
+
+    public ICronetEngineBuilder setDnsOptions(DnsOptions dnsOptions) {
+        return this;
+    }
+
+    public ICronetEngineBuilder setConnectionMigrationOptions(
+            ConnectionMigrationOptions connectionMigrationOptions) {
+        return this;
+    }
+
     public abstract ICronetEngineBuilder setExperimentalOptions(String options);
     public abstract ICronetEngineBuilder setLibraryLoader(
             CronetEngine.Builder.LibraryLoader loader);
     public abstract ICronetEngineBuilder setStoragePath(String value);
+
     public abstract ICronetEngineBuilder setUserAgent(String userAgent);
+
     public abstract String getDefaultUserAgent();
+
     public abstract ExperimentalCronetEngine build();
 
+    /**
+     * Returns the set of configuration options the builder is able to support natively. This is
+     * used internally to emulate newly added functionality using older APIs where possible.
+     *
+     * <p>The default implementation returns an empty set. Subclasses should override this method to
+     * reflect the supported options that are applicable to them.
+     */
+    protected Set<Integer> getSupportedConfigOptions() {
+        return Collections.emptySet();
+    }
+
     // Experimental API methods.
     //
     // Note: all experimental API methods should have default implementation. This will allow
@@ -51,4 +98,4 @@ public abstract class ICronetEngineBuilder {
     public ICronetEngineBuilder setThreadPriority(int priority) {
         return this;
     }
-}
+}
\ No newline at end of file
diff --git a/components/cronet/android/api/src/org/chromium/net/QuicOptions.java b/components/cronet/android/api/src/org/chromium/net/QuicOptions.java
new file mode 100644
index 0000000000000..f0c7b0fcdeefa
--- /dev/null
+++ b/components/cronet/android/api/src/org/chromium/net/QuicOptions.java
@@ -0,0 +1,665 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.net;
+
+import androidx.annotation.Nullable;
+
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * Configuration options for QUIC in Cronet.
+ *
+ * <p>The settings in this class are only relevant if QUIC is enabled. Use
+ * {@link org.chromium.net.CronetEngine.Builder#enableQuic(boolean)} to enable / disable QUIC for
+ * the Cronet engine.
+ */
+public class QuicOptions {
+    private final Set<String> mQuicHostAllowlist;
+    private final Set<String> mEnabledQuicVersions;
+
+    private final Set<String> mConnectionOptions;
+    private final Set<String> mClientConnectionOptions;
+    @Nullable
+    private final Integer mInMemoryServerConfigsCacheSize;
+    @Nullable
+    private final String mHandshakeUserAgent;
+    @Nullable
+    private final Boolean mRetryWithoutAltSvcOnQuicErrors;
+    @Nullable
+    private final Boolean mEnableTlsZeroRtt;
+
+    @Nullable
+    private final Long mPreCryptoHandshakeIdleTimeoutSeconds;
+    @Nullable
+    private final Long mCryptoHandshakeTimeoutSeconds;
+
+    @Nullable
+    private final Long mIdleConnectionTimeoutSeconds;
+    @Nullable
+    private final Long mRetransmittableOnWireTimeoutMillis;
+
+    @Nullable
+    private final Boolean mCloseSessionsOnIpChange;
+    @Nullable
+    private final Boolean mGoawaySessionsOnIpChange;
+
+    @Nullable
+    private final Long mInitialBrokenServicePeriodSeconds;
+    @Nullable
+    private final Boolean mIncreaseBrokenServicePeriodExponentially;
+    @Nullable
+    private final Boolean mDelayJobsWithAvailableSpdySession;
+
+    private final Set<String> mExtraQuicheFlags;
+
+    QuicOptions(Builder builder) {
+        this.mQuicHostAllowlist =
+                Collections.unmodifiableSet(new LinkedHashSet<>(builder.mQuicHostAllowlist));
+        this.mEnabledQuicVersions =
+                Collections.unmodifiableSet(new LinkedHashSet<>(builder.mEnabledQuicVersions));
+        this.mConnectionOptions =
+                Collections.unmodifiableSet(new LinkedHashSet<>(builder.mConnectionOptions));
+        this.mClientConnectionOptions =
+                Collections.unmodifiableSet(new LinkedHashSet<>(builder.mClientConnectionOptions));
+        this.mInMemoryServerConfigsCacheSize = builder.mInMemoryServerConfigsCacheSize;
+        this.mHandshakeUserAgent = builder.mHandshakeUserAgent;
+        this.mRetryWithoutAltSvcOnQuicErrors = builder.mRetryWithoutAltSvcOnQuicErrors;
+        this.mEnableTlsZeroRtt = builder.mEnableTlsZeroRtt;
+        this.mPreCryptoHandshakeIdleTimeoutSeconds = builder.mPreCryptoHandshakeIdleTimeoutSeconds;
+        this.mCryptoHandshakeTimeoutSeconds = builder.mCryptoHandshakeTimeoutSeconds;
+        this.mIdleConnectionTimeoutSeconds = builder.mIdleConnectionTimeoutSeconds;
+        this.mRetransmittableOnWireTimeoutMillis = builder.mRetransmittableOnWireTimeoutMillis;
+        this.mCloseSessionsOnIpChange = builder.mCloseSessionsOnIpChange;
+        this.mGoawaySessionsOnIpChange = builder.mGoawaySessionsOnIpChange;
+        this.mInitialBrokenServicePeriodSeconds = builder.mInitialBrokenServicePeriodSeconds;
+        this.mIncreaseBrokenServicePeriodExponentially =
+                builder.mIncreaseBrokenServicePeriodExponentially;
+        this.mDelayJobsWithAvailableSpdySession = builder.mDelayJobsWithAvailableSpdySession;
+        this.mExtraQuicheFlags =
+                Collections.unmodifiableSet(new LinkedHashSet<>(builder.mExtraQuicheFlags));
+    }
+
+    /**
+     * See {@link Builder#addAllowedQuicHost}
+     */
+    public Set<String> getQuicHostAllowlist() {
+        return mQuicHostAllowlist;
+    }
+
+    /**
+     * See {@link Builder#addEnabledQuicVersion}
+     *
+     * {@hide}
+     */
+    @QuichePassthroughOption
+    public Set<String> getEnabledQuicVersions() {
+        return mEnabledQuicVersions;
+    }
+
+    /**
+     * See {@link Builder#addConnectionOption}
+     *
+     * {@hide}
+     */
+    @QuichePassthroughOption
+    public Set<String> getConnectionOptions() {
+        return mConnectionOptions;
+    }
+
+    /**
+     * See {@link Builder#addClientConnectionOption}
+     *
+     * {@hide}
+     */
+    @QuichePassthroughOption
+    public Set<String> getClientConnectionOptions() {
+        return mClientConnectionOptions;
+    }
+
+    /**
+     * See {@link Builder#setInMemoryServerConfigsCacheSize}
+     */
+    @Nullable
+    public Integer getInMemoryServerConfigsCacheSize() {
+        return mInMemoryServerConfigsCacheSize;
+    }
+
+    /**
+     * See {@link Builder#setHandshakeUserAgent}
+     */
+    @Nullable
+    public String getHandshakeUserAgent() {
+        return mHandshakeUserAgent;
+    }
+
+    /**
+     * See {@link Builder#retryWithoutAltSvcOnQuicErrors}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getRetryWithoutAltSvcOnQuicErrors() {
+        return mRetryWithoutAltSvcOnQuicErrors;
+    }
+
+    /**
+     * See {@link Builder#enableTlsZeroRtt}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getEnableTlsZeroRtt() {
+        return mEnableTlsZeroRtt;
+    }
+
+    /**
+     * See {@link Builder#setPreCryptoHandshakeIdleTimeoutSeconds}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Long getPreCryptoHandshakeIdleTimeoutSeconds() {
+        return mPreCryptoHandshakeIdleTimeoutSeconds;
+    }
+
+    /**
+     * See {@link Builder#setCryptoHandshakeTimeoutSeconds}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Long getCryptoHandshakeTimeoutSeconds() {
+        return mCryptoHandshakeTimeoutSeconds;
+    }
+
+    /**
+     * See {@link Builder#setIdleConnectionTimeoutSeconds}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Long getIdleConnectionTimeoutSeconds() {
+        return mIdleConnectionTimeoutSeconds;
+    }
+
+    /**
+     * See {@link Builder#setRetransmittableOnWireTimeoutMillis}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Long getRetransmittableOnWireTimeoutMillis() {
+        return mRetransmittableOnWireTimeoutMillis;
+    }
+
+    /**
+     * See {@link Builder#closeSessionsOnIpChange}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getCloseSessionsOnIpChange() {
+        return mCloseSessionsOnIpChange;
+    }
+
+    /**
+     * See {@link Builder#goawaySessionsOnIpChange}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getGoawaySessionsOnIpChange() {
+        return mGoawaySessionsOnIpChange;
+    }
+
+    /**
+     * See {@link Builder#setInitialBrokenServicePeriodSeconds}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Long getInitialBrokenServicePeriodSeconds() {
+        return mInitialBrokenServicePeriodSeconds;
+    }
+
+    /**
+     * See {@link Builder#increaseBrokenServicePeriodExponentially}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getIncreaseBrokenServicePeriodExponentially() {
+        return mIncreaseBrokenServicePeriodExponentially;
+    }
+
+    /**
+     * See {@link Builder#delayJobsWithAvailableSpdySession}
+     *
+     * {@hide}
+     */
+    @Experimental
+    @Nullable
+    public Boolean getDelayJobsWithAvailableSpdySession() {
+        return mDelayJobsWithAvailableSpdySession;
+    }
+
+    /**
+     * See {@link Builder#addExtraQuicheFlag}
+     *
+     * {@hide}
+     */
+    @QuichePassthroughOption
+    public Set<String> getExtraQuicheFlags() {
+        return mExtraQuicheFlags;
+    }
+
+    /**
+     * Create a new {@code QuicOptions} builder.
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /**
+     * Builder for {@link QuicOptions}.
+     */
+    public static class Builder {
+        private final Set<String> mQuicHostAllowlist = new LinkedHashSet<>();
+        private final Set<String> mEnabledQuicVersions = new LinkedHashSet<>();
+        private final Set<String> mConnectionOptions = new LinkedHashSet<>();
+        private final Set<String> mClientConnectionOptions = new LinkedHashSet<>();
+        @Nullable
+        private Integer mInMemoryServerConfigsCacheSize;
+        @Nullable
+        private String mHandshakeUserAgent;
+        @Nullable
+        private Boolean mRetryWithoutAltSvcOnQuicErrors;
+        @Nullable
+        private Boolean mEnableTlsZeroRtt;
+        @Nullable
+        private Long mPreCryptoHandshakeIdleTimeoutSeconds;
+        @Nullable
+        private Long mCryptoHandshakeTimeoutSeconds;
+        @Nullable
+        private Long mIdleConnectionTimeoutSeconds;
+        @Nullable
+        private Long mRetransmittableOnWireTimeoutMillis;
+        @Nullable
+        private Boolean mCloseSessionsOnIpChange;
+        @Nullable
+        private Boolean mGoawaySessionsOnIpChange;
+        @Nullable
+        private Long mInitialBrokenServicePeriodSeconds;
+        @Nullable
+        private Boolean mIncreaseBrokenServicePeriodExponentially;
+        @Nullable
+        private Boolean mDelayJobsWithAvailableSpdySession;
+        @Nullable
+        private final Set<String> mExtraQuicheFlags = new LinkedHashSet<>();
+
+        Builder() {}
+
+        /**
+         * Adds a host to the QUIC allowlist.
+         *
+         * <p>If no hosts are specified, the per-host allowlist functionality is disabled.
+         * Otherwise, Cronet will only use QUIC when talking to hosts on the allowlist.
+         *
+         * @return the builder for chaining
+         */
+        public Builder addAllowedQuicHost(String quicHost) {
+            mQuicHostAllowlist.add(quicHost);
+            return this;
+        }
+
+        /**
+         * Adds a QUIC version to the list of QUIC versions to enable.
+         *
+         * <p>If no versions are specified, Cronet will use a list of default QUIC versions.
+         *
+         * <p>The version format is specified by
+         * <a
+         * href="https://github.com/google/quiche/blob/main/quiche/quic/core/quic_versions.cc#L344">QUICHE</a>.
+         * Outside of filtering out values known to be obsolete, Cronet doesn't process the versions
+         * anyhow and simply passes them along to QUICHE.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @QuichePassthroughOption
+        public Builder addEnabledQuicVersion(String enabledQuicVersion) {
+            mEnabledQuicVersions.add(enabledQuicVersion);
+            return this;
+        }
+
+        /**
+         * Adds a QUIC tag to send in a QUIC handshake's connection options.
+         *
+         * <p>The QUIC tags should be presented as strings up to four letters long
+         * (for instance, {@code NBHD}).
+         *
+         * <p>As the QUIC tags are under active development and some are only relevant to the
+         * server, Cronet doesn't attempt to maintain a complete list of all supported QUIC flags as
+         * a part of the API. The flags. Flags supported by QUICHE, a QUIC implementation used by
+         * Cronet and Google servers, can be found <a
+         * href=https://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h">here</a>.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @QuichePassthroughOption
+        public Builder addConnectionOption(String connectionOption) {
+            mConnectionOptions.add(connectionOption);
+            return this;
+        }
+
+        /**
+         * Adds a QUIC tag to send in a QUIC handshake's connection options that only affects
+         * the client.
+         *
+         * <p>See {@link #addConnectionOption(String)} for more details.
+         *
+         * {@hide}
+         */
+        @QuichePassthroughOption
+        public Builder addClientConnectionOption(String clientConnectionOption) {
+            mClientConnectionOptions.add(clientConnectionOption);
+            return this;
+        }
+
+        /**
+         * Sets how many server configurations (metadata like list of alt svc, whether QUIC is
+         * supported, etc.) should be held in memory.
+         *
+         * <p>If the storage path is set ({@link
+         * CronetEngine.Builder#setStoragePath(String)}, Cronet will also persist
+         * the server configurations on disk.
+         *
+         * @return the builder for chaining
+         */
+        public Builder setInMemoryServerConfigsCacheSize(int inMemoryServerConfigsCacheSize) {
+            this.mInMemoryServerConfigsCacheSize = inMemoryServerConfigsCacheSize;
+            return this;
+        }
+
+        /**
+         * Sets the user agent to be used outside of HTTP requests (for example for QUIC
+         * handshakes).
+         *
+         * <p>To set the default user agent for HTTP requests, use
+         * {@link CronetEngine.Builder#setUserAgent(String)} instead.
+         *
+         * @return the builder for chaining
+         */
+        public Builder setHandshakeUserAgent(String handshakeUserAgent) {
+            this.mHandshakeUserAgent = handshakeUserAgent;
+            return this;
+        }
+
+        /**
+         * Sets whether requests that failed with a QUIC protocol errors should be retried without
+         * using any {@code alt-svc} servers.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder retryWithoutAltSvcOnQuicErrors(boolean retryWithoutAltSvcOnQuicErrors) {
+            this.mRetryWithoutAltSvcOnQuicErrors = retryWithoutAltSvcOnQuicErrors;
+            return this;
+        }
+
+        /**
+         * Sets whether TLS with 0-RTT should be enabled.
+         *
+         * <p>0-RTT is a performance optimization avoiding an extra round trip when resuming
+         * connections to a known server.
+         *
+         * @see <a href="https://blog.cloudflare.com/introducing-0-rtt/">Cloudflare's 0-RTT
+         *         blogpost</a>
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder enableTlsZeroRtt(boolean enableTlsZeroRtt) {
+            this.mEnableTlsZeroRtt = enableTlsZeroRtt;
+            return this;
+        }
+
+        /**
+         * Sets the maximum idle time for a connection which hasn't completed a SSL handshake yet.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setPreCryptoHandshakeIdleTimeoutSeconds(
+                long preCryptoHandshakeIdleTimeoutSeconds) {
+            this.mPreCryptoHandshakeIdleTimeoutSeconds = preCryptoHandshakeIdleTimeoutSeconds;
+            return this;
+        }
+
+        /**
+         * Sets the timeout for a connection SSL handshake.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setCryptoHandshakeTimeoutSeconds(long cryptoHandshakeTimeoutSeconds) {
+            this.mCryptoHandshakeTimeoutSeconds = cryptoHandshakeTimeoutSeconds;
+            return this;
+        }
+
+        /**
+         * Sets the maximum idle time for a connection.
+         *
+         * TODO what happens to connection that are idle for too long?
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setIdleConnectionTimeoutSeconds(long idleConnectionTimeoutSeconds) {
+            this.mIdleConnectionTimeoutSeconds = idleConnectionTimeoutSeconds;
+            return this;
+        }
+
+        /**
+         * Sets the maximum desired time between packets on wire.
+         *
+         * <p>When the retransmittable-on-wire time is exceeded Cronet will probe quality of the
+         * network using artificial traffic. Smaller timeouts will typically  result in faster
+         * discovery of a broken or degrading path, but also larger usage of resources (battery,
+         * data).
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setRetransmittableOnWireTimeoutMillis(
+                long retransmittableOnWireTimeoutMillis) {
+            this.mRetransmittableOnWireTimeoutMillis = retransmittableOnWireTimeoutMillis;
+            return this;
+        }
+
+        /**
+         * Sets whether QUIC sessions should be closed on IP address change.
+         *
+         * <p>Don't use in combination with connection migration
+         * (configured using {@link ConnectionMigrationOptions}).
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder closeSessionsOnIpChange(boolean closeSessionsOnIpChange) {
+            this.mCloseSessionsOnIpChange = closeSessionsOnIpChange;
+            return this;
+        }
+
+        /**
+         * Sets whether QUIC sessions should be goaway'd on IP address change.
+         *
+         * <p>Don't use in combination with connection migration
+         * (configured using {@link ConnectionMigrationOptions}).
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder goawaySessionsOnIpChange(boolean goawaySessionsOnIpChange) {
+            this.mGoawaySessionsOnIpChange = goawaySessionsOnIpChange;
+            return this;
+        }
+
+        /**
+         * Sets the initial for which Cronet shouldn't attempt to use QUIC for a given server after
+         * the server's QUIC support turned out to be broken.
+         *
+         * <p>Once Cronet detects that a server advertises QUIC but doesn't actually speak it, it
+         * marks the server as broken and doesn't attempt to use QUIC when talking to the server for
+         * an amount of time. Once Cronet is past this point it will try using QUIC again. This is
+         * to balance short term (there's no point wasting resources to try QUIC if the server is
+         * broken) and long term (the breakage might have been temporary, using QUIC is generally
+         * beneficial) interests.
+         *
+         * <p>The delay is increased every unsuccessful consecutive retry. See
+         * {@link #increaseBrokenServicePeriodExponentially(boolean)} for details.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder setInitialBrokenServicePeriodSeconds(
+                long initialBrokenServicePeriodSeconds) {
+            this.mInitialBrokenServicePeriodSeconds = initialBrokenServicePeriodSeconds;
+            return this;
+        }
+
+        /**
+         * Sets whether the broken server period should scale exponentially.
+         *
+         * <p>If set to true, the initial delay (configurable
+         * by {@link #setInitialBrokenServicePeriodSeconds}) will be scaled exponentially for
+         * subsequent retries ({@code SCALING_FACTOR^NUM_TRIES * delay}). If false, the delay will
+         * scale linearly (SCALING_FACTOR * NUM_TRIES * delay).
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder increaseBrokenServicePeriodExponentially(
+                boolean increaseBrokenServicePeriodExponentially) {
+            this.mIncreaseBrokenServicePeriodExponentially =
+                    increaseBrokenServicePeriodExponentially;
+            return this;
+        }
+
+        /**
+         * Sets whether Cronet should wait for the primary path (usually QUIC) to be ready even if
+         * there's a secondary path of reaching the server (SPDY / HTTP2) which is ready
+         * immediately.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @Experimental
+        public Builder delayJobsWithAvailableSpdySession(
+                boolean delayJobsWithAvailableSpdySession) {
+            this.mDelayJobsWithAvailableSpdySession = delayJobsWithAvailableSpdySession;
+            return this;
+        }
+
+        /**
+         * Sets an arbitrary QUICHE flag. Flags should be passed in {@code FLAG_NAME=FLAG_VALUE}
+         * format.
+         *
+         * See the <a href="https://github.com/google/quiche/">QUICHE code base</a> for a full list
+         * of flags.
+         *
+         * @return the builder for chaining
+         *
+         * {@hide}
+         */
+        @QuichePassthroughOption
+        public Builder addExtraQuicheFlag(String extraQuicheFlag) {
+            this.mExtraQuicheFlags.add(extraQuicheFlag);
+            return this;
+        }
+
+        /**
+         * Creates and returns the final {@link QuicOptions} instance, based on the values
+         * in this builder.
+         */
+        public QuicOptions build() {
+            return new QuicOptions(this);
+        }
+    }
+
+    /**
+     * An annotation for APIs which are not considered stable yet.
+     *
+     * <p>Applications using experimental APIs must acknowledge that they're aware of using APIs
+     * that are not considered stable. The APIs might change functionality, break or cease to exist
+     * without notice.
+     *
+     * <p>It's highly recommended to reach out to Cronet maintainers ({@code net-dev@chromium.org})
+     * before using one of the APIs annotated as experimental outside of debugging
+     * and proof-of-concept code. Be ready to help to help polishing the API, or for a "sorry,
+     * really not production ready yet".
+     *
+     * <p>If you still want to use an experimental API in production, you're doing so at your
+     * own risk. You have been warned.
+     *
+     * {@hide}
+     */
+    public @interface Experimental {}
+
+    /**
+     * An annotation for APIs which configure QUICHE options not curated by Cronet.
+     *
+     * <p>APIs annotated by this are considered stable from Cronet's perspective. However, they
+     * simply pass the configuration options to QUICHE, a library that provides the HTTP3
+     * implementation. As the dependency is under active development those flags might change
+     * behavior, or get deleted. The application accepts the stability contract as stated by QUICHE.
+     * Cronet is just a mediator passing the messages back and forth.
+     *
+     * <p>Cronet provides the APIs as a compromise between customer development velocity (some
+     * customers value access to bleeding edge QUICHE features ASAP), and Cronet's own interests
+     * (stability and readability of the API, capacity to propagate new QUICHE changes). Most Cronet
+     * customers shouldn't need to use those APIs directly. Mature QUICHE features that are
+     * generally useful will be exposed by Cronet as proper top level APIs or configuration options.
+     *
+     * {@hide}
+     */
+    public @interface QuichePassthroughOption {}
+}
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
index e4c2df648b454..d2443b4d4470e 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
@@ -830,4 +830,4 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         @NativeClassQualifiedName("CronetContextAdapter")
         boolean skipLogging(long nativePtr, CronetUrlRequestContext caller);
     }
-}
+}
\ No newline at end of file
-- 
2.39.1.405.gd4c25cc71f-goog

